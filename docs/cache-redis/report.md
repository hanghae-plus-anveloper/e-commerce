# E-commerce 캐싱 전략 - Redis 

## 캐시가 필요한 부분 분석

### 조건

- 동일한 파라미터로 반복적인 조회가 발생하는 경우
- 쿼리 연산의 비용의 큰 경우
- 변경 빈도가 낮아 특정 시간동안 같은 정보를 제공해도 값이 유효한 경우

### 피해야 할 조건

- 명확한 캐싱 키가 없는 경우
- 쿼리 연산의 비용이 작아 캐싱의 이득이 적은 경우
- 실시간 데이터처럼, 일관성이 중요한 경우
- 쓰기 빈도가 높아 변경이 자주 발생하는 경우

### 캐싱 대상 서비스 판단

- 조회와 관련된 서비스 기능
  - 잔액 조회 API 
    - 사용자 별 조회를 하더라도, 충전이나 사용이 빈번함
    - 일관성이 중요한 기능으로 **캐싱 불필요 판단**
  - 상품 조회 API
    - 상품 읽기에 대한 접근은 매우 빈번하고, 상품 메타 데이터의 경우 변경이 적음(재고 제외)
    - 재고값의 경우 수정이 빈번함.
    - 현재 상품 테이블은 재고 테이블이 분리되어있지 않고, 조회 쿼리 비용이 높지 않음.
      - ID, 이름, 가격, 재고 
    - 따라서, 현재는 **캐싱 불필요 판단**
  - 상위 상품 조회 API
    - 상품 별, 일자 별, 주문 수량 관련하여 쿼리 연산이 복잡함
    - 연산을 해야하는 주문 테이블의 경우, 당일을 포함하면 주문량에 따라 변경되는 정보이지만,
    - -1 ~ -3일을 기준으로 캐싱 하는 경우 하루 단위의 캐싱이 가능

## 